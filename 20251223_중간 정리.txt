다만, “빠뜨린 것”이 아니라 “마무리 체크”로 꼭 6가지는 확인하세요 (무결성 관점)
1) 설정 고정(Freeze)과 단일 진실 소스(SSOT)

runtime YAML이 유일한 진실(SSOT) 이 되게 하세요.
지금처럼 demo_cli는 runtime YAML을 읽고, agent retrieve_node도 runtime YAML을 읽게 되어 있으면 OK.

체크: 어딘가에서 AIHubIndexConfig.default()로 다시 덮어써서 quota가 rrf로 돌아가는 지점이 없는지만 마지막으로 grep 하면 됩니다.

예: AIHubFusedRetriever.build(cfg)를 직접 호출하는 코드가 남아있으면 “quota 설정”이 무시될 수 있음 → runtime builder로 통일.

2) 평가 누수(leakage) 통제 방식 문서화

지금은 self-hit만 제거했지만, 심사자는 보통 이렇게 묻습니다:

“같은 분과/같은 q_type의 거의 동일한 문제가 인덱스에 남아있으면 사실상 힌트로 정답을 본 거 아닌가?”
→ 해결은 “추가 튜닝”이 아니라 연구 설계 문서화입니다.

권장 문장(논문에 그대로 넣을 수 있는 형태):

“TL은 학습(인덱싱) 데이터에 포함된 유사 Q&A 패턴을 ‘힌트’로 사용하되, 평가 시에는 동일 origin_path를 가진 항목을 제거(self-hit filtering) 하고, 평가지표는 도메인/질문유형 일치율 및 최종 응답 품질로 분리 측정한다.”

(여기서 더 엄밀히 하려면 “origin_path 단위 holdout”까지 가면 되지만, 지금은 **본론(컨텍스트 엔지니어링)**이 핵심이니 self-hit 제거 + 문서화로 충분합니다.)

3) “TS는 근거, TL은 힌트” 규칙을 코드/프롬프트 모두에 고정

무결성 포인트는 하나입니다:

LLM 프롬프트에 TL을 ‘근거처럼’ 넣지 말 것
(TL은 구조/포인트 가이드로만 쓰고, 근거 인용은 TS만)

지금 repo 흐름 기준으로 추천 고정:

retrieved_docs = TS(in_fused) 우선 (없으면 ts_pool)

TL은 tl_hints로 별도 제공 → “답변 설계(Answer Plan)” 단계에서만 참조

4) 로그/재현성(Seeds/버전/런타임 설정) 최소 세트

심사에서 재현가능성을 보려면, 매 실행마다 최소한 아래가 남아야 합니다.

runtime_yaml 경로 + 핵심 파라미터(out_k, quotas, strategy, no_self_hit)

fused 결과에서 TL/TS 개수

TS_in_fused_support / rescue-rate 같은 “설계 의도” 지표

(이미 TS_in_fused_support를 넣으셨으니 방향은 매우 좋습니다.)

5) 성능 안정화: 캐시 1회 로드 원칙

이건 튜닝이 아니라 실전 실행 안정성입니다.

SentenceTransformer, npy 인덱스 로드는 프로세스에서 1회만
(지금처럼 lru_cache 형태면 OK)

6) 안전성(의료) 가드레일 + Quality Check 고정

사용자 요청하신 “quality check 타이트 고정”은 연구 본론에서 중요합니다.

QC에서 근거 부족/불확실이면: “추가 질문”으로 강제

Red-flag(응급 증상)면: “즉시 의료기관 안내”로 강제
이 두 가지가 “컨텍스트 엔지니어링 기반 의료 에이전트”의 설계 정체성을 만들어줍니다.